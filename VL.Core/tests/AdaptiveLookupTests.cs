using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Emit;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using VL.Core.CompilerServices;
using System.Collections.Immutable;
using VL.AppServices.CompilerServices;

namespace VL.Core.Tests
{
    [TestFixture]
    public class AdaptiveLookupTests
    {
        [Test]
        public void CombinedLookupTest()
        {
            var m = typeof(AdaptiveLookup).GetMethod("Equ", new[] { typeof(List<float>), typeof(List<float>) });
            var asemblyName = new AssemblyName("AutoGenerated");
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(asemblyName, AssemblyBuilderAccess.Run);
            var moduleBuilder = assemblyBuilder.DefineDynamicModule(asemblyName.Name!);

            {
                var provider = new AdaptiveImplementationProvider(typeof(AdaptiveLookup));
                var type = provider.GenerateStruct(typeof(IAdaptiveLerp<float>));
                var instance = Activator.CreateInstance(type);
                var lerp = (IAdaptiveLerp<float>)instance;
                lerp.Lerp(1f, 2f, 1f, out var r);
                Assert.IsTrue(r == 2f);
            }
            {
                var provider = new AdaptiveImplementationProvider(typeof(AdaptiveLookup));
                var type = provider.GenerateStruct(typeof(IAdaptiveLerp<List<float>>));
                var instance = Activator.CreateInstance(type);
                var lerp = (IAdaptiveLerp<List<float>>)instance;
                lerp.Lerp(new List<float>() { 1f }, new List<float>() { 2f }, 1f, out var r);
                Assert.IsTrue(r[0] == 2f);
            }
            {
                bool result;
                query<IAdaptiveEqu<List<float>>>(typeof(AdaptiveLookup)).Equ(list(0f), list(1f - 1f), out result);
                Assert.IsTrue(result, "0f == 1f-1f");

                query<IAdaptiveEqu<MyFloatList>>(typeof(AdaptiveLookup)).Equ(new MyFloatList(), new MyFloatList(), out result);
                Assert.IsTrue(result, "two MyFloatList instances are equal");

                // Doesn't work:
                //query<IAdaptiveEqu<List<MyFloatList>>>(typeof(AdaptiveLookup)).Equ(list(new MyFloatList()), list(new MyFloatList()), out result);
                //Assert.IsTrue(result, $"lists of MyfloatLists equal");

                query<IAdaptiveFoo<float>>(typeof(AdaptiveLookup)).Foo(0f, 1f - 1f);
                //Console.WriteLine();

                createInstance(typeof(AdaptiveLookup), typeof(IAdaptiveEqu<List<MyFloatList>>), typeof(IAdaptiveEqu<MyFloatList>));
                //Console.WriteLine();

                // two interfaces share one implementation
                var o = createInstance(typeof(AdaptiveLookup), typeof(IAdaptiveEqu<float>), typeof(IAdaptiveEqu2<float>));
                var interfaces = o.GetType().GetInterfaces();
                var methods = o.GetType().GetMethods().Where(m => m.Name == "Equ").ToArray();
                Assert.IsTrue(interfaces.Length == 2);
                Assert.IsTrue(methods.Length == 1);
                ((IAdaptiveEqu<float>)o).Equ(0, 0, out var x);
                ((IAdaptiveEqu2<float>)o).Equ(0, 0, out var y);
            }

            // we expect a match on the exact implementation
            {
                var o = createInstance(typeof(InterpolationLookup), typeof(IAdaptiveCreateInterpolationUI<LinearInterpolationModel, IKeyframeUI<float>>));
                ((IAdaptiveCreateInterpolationUI<LinearInterpolationModel, IKeyframeUI<float>>)o).CreateInterpolationUI(default, default, out var x);
                Assert.IsTrue(x == 1);
            }

            // we expect a match on the fallback implementation
            {
                var o = createInstance(typeof(InterpolationLookup), typeof(IAdaptiveCreateInterpolationUI<SomeInterpolationModel, IKeyframeUI<float>>));
                ((IAdaptiveCreateInterpolationUI<SomeInterpolationModel, IKeyframeUI<float>>)o).CreateInterpolationUI(default, default, out var x);
                Assert.IsTrue(x == 0);
            }

            // we expect a match on the fallback implementation
            {
                var o = createInstance(typeof(InterpolationLookup), typeof(IAdaptiveCreateInterpolationUI<IInterpolationModel, IKeyframeUI<float>>));
                ((IAdaptiveCreateInterpolationUI<IInterpolationModel, IKeyframeUI<float>>)o).CreateInterpolationUI(default, default, out var x);
                Assert.IsTrue(x == 0);
            }

            List<T> list<T>(params T[] el) => el.ToList();
            T query<T>(Type adaptiveLookup) where T : class
            {
                Type adaptive = typeof(T);
                //Console.WriteLine("Query:");
                //Console.WriteLine("   " + AdaptiveImplementationProvider.CSharpName(adaptive));
                //Console.WriteLine("Result:");
                return createInstance(adaptiveLookup, adaptive) as T;
            }
            object createInstance(Type adaptiveLookup, params Type[] adaptives)
            {
                var result = AdaptiveImplementationProvider.GetConsolidatedImplementations(witness: null, ImmutableArray.Create(adaptiveLookup), adaptives).Keys;
                //foreach (var item in result)
                //    Console.WriteLine("   " + item);

                var provider = new AdaptiveImplementationProvider(adaptiveLookup);
                var type = provider.GenerateStruct(adaptives);
                return Activator.CreateInstance(type);
            }
        }

        // Adaptives
        public interface IAdaptiveLerp<T>
        {
            void Lerp(T a, T b, float s, out T r);
        }
        public interface IAdaptiveEqu<T>
        {
            public void Equ(T a, T b, out bool result);
        }
        public interface IAdaptiveEqu2<T>
        {
            public void Equ(T a, T b, out bool result);
        }
        public interface IAdaptiveCreateDefaut<T>
        {
            public void CreateDefaut(out T result);
        }
        public interface IAdaptiveFoo<T>
        {
            public void Foo(float a, T b);
        }

        // Adaptive Implementations
        class FloatUtils
        {
            public static bool Equ(ref float b, ref float a) => a == b;
        }
        class ListUtils
        {
            public static bool Equ<T, AdM>(List<T> a, List<T> b) where AdM : struct, IAdaptiveEqu<T> => Enumerable.SequenceEqual(a, b);
        }
        class EnumerableUtils
        {
            public static bool Equ<T, AdM>(IEnumerable<T> a, IEnumerable<T> b) where AdM : struct, IAdaptiveEqu<T> => Enumerable.SequenceEqual(a, b);
        }

        // User Code
        public class MyFloatList : List<float> { }
        class Foo_Generic<T>
        {
            public void Update<AdM>(List<T> a, List<T> b)
                where AdM : struct, IAdaptiveEqu<List<T>>
            {
                var witness = default(AdM);
                // = (a, b)
                witness.Equ(a, b, out var r);
            }
        }
        class Entrypoint
        {
            public void Update()
            {
                var foo = new Foo_Generic<float>();
                var a = new List<float>();
                var b = new List<float>();

                foo.Update<ToBeGenerated>(a, b);


                //var foo2 = API.MakeGenericType(typeof(Foo_Generic<>), typeof(float));
            }
        }

        // Collected Implementations
        public class AdaptiveLookup
        {
            public static void Equ(float a, float b, out bool result) { result = FloatUtils.Equ(ref b, ref a); }
            public static void Equ(float a, float b, float c, out bool result) { result = FloatUtils.Equ(ref b, ref a); }
            public static void Equ<T>(T a, T b, out bool result) { throw new Exception(); }
            public static void Equ(IEnumerable<float> a, IEnumerable<float> b, out bool result) { result = object.Equals(a, b); }
            public static void Equ(List<float> a, List<float> b, out bool result) { result = Enumerable.SequenceEqual(a, b); }
            public static void Equ(List<List<float>> a, List<List<float>> b, out bool result) { result = ListUtils.Equ<List<float>, EarlyWitness>(a, b); }
            public static void Equ<T, AdM>(List<T> a, List<T> b, out bool result) where AdM : struct, IAdaptiveEqu<T> { result = ListUtils.Equ<T, AdM>(a, b); }
            public static void Equ<T, AdM>(IEnumerable<T> a, IEnumerable<T> b, out bool result) where AdM : struct, IAdaptiveEqu<T> { result = EnumerableUtils.Equ<T, AdM>(a, b); }

            public static void Foo<T>(float a, T b) { }

            // Should be found for e.g. IAdaptiveLerp<Spread<Vector2>>
            //public static void Lerp<T, AdM>(IEnumerable<T> a, IEnumerable<T> b, float s, out IEnumerable<T> r) where AdM : struct, IAdaptiveLerp<T> => throw new NotImplementedException();


            public static void Lerp(float a, float b, float s, out float r) => r = a * (1 - s) + b * s;

            public static void Lerp<T, AdM>(List<T> a, List<T> b, float s, out List<T> r)
                where AdM : struct, IAdaptiveLerp<T>
            {
                var w = default(AdM);
                r = new List<T>(Math.Min(a.Count, b.Count));
                for (int i = 0; i < a.Count; i++)
                {
                    w.Lerp(a[i], b[i], s, out var x);
                    r.Add(x);
                }
            }
        }

        struct EarlyWitness : IAdaptiveEqu<List<float>>
        {
            public void Equ(List<float> a, List<float> b, out bool result)
            {
                AdaptiveLookup.Equ((IEnumerable<float>)a, (IEnumerable<float>)b, out result);
            }
        }
        // Test struct to look at generated IL with ildasm.exe (through VS command line)
        struct ToBeEmitted : IAdaptiveLerp<float>
        {
            public void Lerp(float a, float b, float s, out float r)
            {
                AdaptiveLookup.Lerp(a, b, s, out r);
            }
        }
        struct ToBeGenerated : IAdaptiveEqu<List<float>>, IAdaptiveEqu<float>, IAdaptiveEqu2<float>
        {
            void IAdaptiveEqu<float>.Equ(float a, float b, out bool result)
            {
                AdaptiveLookup.Equ((float)a, (float)b, out result);
            }

            public void Equ(List<float> a, List<float> b, out bool result)
            {
                AdaptiveLookup.Equ<float, ToBeGenerated>(a, b, out result);
            }

            void IAdaptiveEqu2<float>.Equ(float a, float b, out bool result)
            {
                AdaptiveLookup.Equ((float)a, (float)b, out result);
            }

        }

        public interface IInterpolationModel { }
        public class LinearInterpolationModel : IInterpolationModel { }
        public class SomeInterpolationModel : IInterpolationModel { }
        public interface IKeyframeUI<T> { }
        public interface IAdaptiveCreateInterpolationUI<TModel, T>
        {
            void CreateInterpolationUI(TModel model, IKeyframeUI<T> keyframeUI, out int x);
        }
        public class InterpolationLookup
        {
            public static void CreateInterpolationUI<T>(IInterpolationModel model, IKeyframeUI<T> keyframeUI, out int x) => x = 0;
            public static void CreateInterpolationUI<T>(LinearInterpolationModel model, IKeyframeUI<T> keyframeUI, out int x) => x = 1;
        }
    }
}
